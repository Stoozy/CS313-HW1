Question 5
5. Create a multi-level sort. For instance, for all selections of n > 10 you do sort X and within sort X, when you have a situation with n < 10 you do sort Y. Be creative. Time your sort against two “reasonably comparable” sorts (you may use libraries for the “reasonably comparable sorts”). 

In this program, we are asked to create a multi-level sort. In the main function, we created an array that is filled with random numbers and has a size of size which can be changed. We filled the array using a for loop and went through every element of the array and set the value of that position to a random number. To sort the array, we call the custom sort function. For the custom sort function I used two types of sorting methods called insertion sort and quicksort. The reason we use these two methods is because they each have their own advantages. An insertion sort is very good at sorting smaller arrays but inefficient at sorting large arrays. This is where quicksort can help us as it can sort the larger arrays. When we first call the array, the function checks to see if the array is greater than 10 elements. If it is, then we use the partition function to get the pivot. Next we check if the ending position is higher than the starting position. If it is, we recursively call the customSort on the left side of the array. Otherwise, we use the customSort on the right side of the array. When the arrays are divided into smaller arrays of size less than 10, we do insertion sort to sort the array. In the end, we get a full sorted array. We then compare the custom sorting function to a sort function from a library using a timing function. We use sort and stable_sort from the algorithm library. We can see that the customSort speed is much faster than the sort function and faster than the stable sort function from the library.

